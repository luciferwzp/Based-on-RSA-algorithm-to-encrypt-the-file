# Based-on-RSA-algorithm-to-encrypt-the-file
# 基于RSA算法对信息进行加密
****

## 1.RSA的命名由来  
1977年，由三位数学家Rivest、Shamir和Adleman设计了一种算法，此算法实现非对称加密。因此这种算法就由他们三人的名字命名，叫做RSA算法。
  
## 2.RSA加密公式  

  加密：公钥(E，N)  
  >>>                  密 文 = (明 文)^E mod N  
                    
  解密：密钥(D，N)  
  >>>                  明 文 = (密 文)^D mod N  
  <br />
RSA的安全主要于大数分解的难度。其公钥是一对大素数(100到200或者更大)的函数。从知道一个公钥和密文翻译出明文的难度，等价于分解了两个大素数之积。
  
## 3.RSA所需数学公式  
  
 __素数(质数)__ ：除过1和本身，不能被其它数整除的数  
**互质数**：公约数只有1的两个数，叫做互质数  
**欧拉函数**：欧拉函数是小于x的正整数中与x互质的数的数目  
两个质数一定是互质数  
  * 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如5和12  
  * 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和88  
  * 1和任意一个自然数是都是互质关系，比如1和100  
  * 相邻的两个自然数是互质数，如 7 与 9  
  * 相邻的两个奇数是互质数 ，如 57与 59    
  
## 4.RSA密钥产生过程
1. 随机选择两个不相等的质数p和q(实际应用中，这两个质数越大，就越难破解)。  
2. 计算p和q的乘积n，n = pq。  
3. 计算n的欧拉函数φ(n)。  
4. 随机选择一个整数e，条件是1< e < φ(n)，且e与φ(n) 互质。  
5. 计算e对于φ(n)的模反元素d，使得de≡1 mod φ(n)，即：  
                                           (de)modφ(n) = 1
7. 产生公钥(e,n)，私钥(d,n)。      
  
## 5.实例描述
1. 选择p = 3, q = 11。  
2. n = pq = 33。  
3. φ(n) = (p - 1)(q - 1) = 20。  
4. 选择e = 3, 此时e与φ(n) 互质。  
5. (de)modφ(n) =(d * 3)mod20=1,求出d=7。  
6. 公钥(3,33)，私钥(7,33)。  
7. 例如对明文数字“5”加密，根据加密公式，密文=(5^3)mod(33) = 125 % 33 = 26。  
8. 把上述密文解密，明文=26^7 % 33 = 8031810176 % 33 = 5。  
  
## 6.快速幂取模运算  
我们计算一个数比如5^1003%31是非常消耗我们的计算资源的，在整个计算过程中最麻烦的就是我们的5^1003这个过程  
  * 缺点1：在我们在之后计算指数的过程中，计算的数字不断增大，非常的占用我们的计算资源    
  * 缺点2：我们计算的中间过程数字大的恐怖，我们现有的计算机是没有办法记录这么长的数据的，会导致溢出。    
  
**同余定理**  
首先介绍一下同余定理，公式如下  
 (a +/- b) % c = ((a % c +/- b % c)) % c  
 (a * b) % c   = ((a % c) * (b % c)) % c  
 
 a^b % c = (a * a * a……a)%c  
         = ((a%c)*(a%c)*(a%c)*……*(a%c))%c  
         = (a % c)^b % c  

**模反元素优化**  
模反元素也成为模的逆元，如果使用暴力搜索，求逆元d的时间复杂度为O(n)，这对于大数性能是无法忍受的。所以
需要更快速的算法。  
  
**欧几里得定理**  
gcd(a,b) = gcd(b, a%b)：(a,b)的最大公约数与(a,a%b)的最大公约数相同。  
如果a,b的最大公约数为gcd，则一定也可以找到x, y, 使等式ax + by = gcd成立。此方程的x,y的解不唯一，可以有无
数组解。  
  
**欧几里得算法----碾转相除法**  
```
int gcd(int a, int b) {
    if(b == 0)
        return a;
    return gcd(b, a%b);
}
```
  
**扩展的欧几里得算法**  
>扩展的欧几里得算法：不仅要求出(a,b)的最大公约数gcd，也要求出其中的一组解(x,y), 满足等式ax + by = gcd。从上面的算法可知当b=0时，gcd即可求出，所以可以在求出gcd的同时也求出(x,y)。 
  
>我们观察一下等式，ax + by = gcd， 当b = 0时， 等式变成了ax = gcd，此时我们返回a的值，a既是所求的最大公约数gcd，故此时x = 1, y可以是任意值， 所以，简单的一组解即为(1, 0)。  
  
>现在再让我们回头看模的逆元的等式：ab%n = 1。 ab - 1为n的倍数， 即 ab + kn = 1, 这里放入加密算法中对应的即为： ed + kφ(n) = 1, 其中e为加密密钥， d为解密密钥， e与φ(n)互质，他们的最大公约数即为1，所以这里的解密密钥d和k就相当于等式的一组解，此解可以用扩展的欧几里得算法求解。  
  
>这里我们假设d = x, k = y, e = a, φ(n) = b, 则等式ed + kφ(n) = 1即变为ax + by = 1, 通过欧几里得递归算法，当b=0时，可求得一组解(1,0)和最大公约为1。  
>递归的时候，在获取最终结果之前，已经求出了下一个状态：b 和 a%b 的最大公约数，假设此时求得了一组解(x1,y1)，使得bx1 + (a % b)y1 = 1。    
>而这里 a % b = a - [a / b] * b， 其中[a/b]表示向下取整， 带入上述等式，即为：  
>>bx1 + (a - [a / b] * b)y1 = 1，继续变形：  
>>bx1 + ay1 - [a/b] * by1 = 1，继续变形：  
>>ay1 + b(x1 - [a/b]y1) = 1  
  
>到此为止，我们发现什么？当我们去求解(x,y)使ax + by = 1，可以看到此解和bx1 + (a % b)y1 = 1的关系如下：  
>>x = y1, y = x1 - [a/b]y1  
  
>即在递归的过程中最终的结果可以通过上次递归的结果推导出来，关系如上所示。算法最终求得一组解(x,y)和最大公约数1。此时我们一般会找出最小的那个解对应的x，如何求得最小的解呢？其实也简单，只需要x%b即可。如果x为一个解，则ax + by = 1, 则它的通解为x + k * b，使a(x + k * b) % b = 1，这里ax % b = 1, (k * b) % b = 0, 总体结果还是为1。所以a关于b的逆元x是一个关于b的同余数，所以一定存在一个最小的正整数，它是a关于b的逆元，而最小的肯定在(0,b)之间。最后一个问题，有时候我们得到的解x是一个负数，所以统一处理，可以直接进行操作： (x % b +b) % b。算法如下：  
```
long Rsa::exgcd(long a, long b, long &x, long &y) {
/*
ax + by = 1
bx1 + (a % b)y1 = 1 -- > 
bx1 + (a - floor(a / b) * b)y1 = 1 -- > 
bx1 + ay1 - floor(a / b) * b*y1 -- > 
b(x1 - floor(a / b) * y1) + ay1 = 1
x = y1   y = x1 - floor(a / b) * y1
*/
//当b=0时，求得最大公约数和对应的一组解(x,y)-->(0,1)
if (b == 0)
 {
x = 1; y = 0;
return a;
 }
long gcd = exgcd(b, a%b, x, y);
    //当前(a,b)对应的解可以通过(b,a%b)推导得出
long x1 = x, y1 = y; x = y1; y = x1 - (a / b) * y1;
return gcd; }
```
  
## 7.RSA加密安全性
RSA密钥产生过程中共生成6个值p，q，n，φ(n)，e，d。除过公钥n，e之外，其它值都是不公开的，p和q一般会销
毁，d不能泄漏。  
  
RSA安全性的高低就取决于通过n和e推导出d的难易程度。  
  
通过密钥产生的第五步可知：  
(ed) mod φ(n) =1。只有知道e和φ(n)，才能算出d。  
φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。  
n=pq,只有将n因数分解，才能算出p和q。  
  
只要求出p和q的值，我们就能求出d的值而得到私钥，但是当p和q是一个大素数的时候，从它们的积pq去分解因子p 和q，这是一个大难题。 
比如对于比较小的数做因式分解很简单(例如： 8415 = 99 * 85)，但是下面这个大整数：
```
12301866845301177551304949
58384962720772853569595334
79219732245215172640050726
36575187452021997864693899
56474942774063845925192557
32630345373154826850791702
61221429134616704292143116
02221240479274737794080665
351419597459856902143413
```

它等于下面两个质数的乘积 ：  
```
  33478071698956898786044169
84821269081770479498371376
85689124313889828837938780
02287614711652531743087737
814467999489
×
36746043666799590428244633
79962795263227915816434308
76426760322838157396665112
79233373417143396810270092
798736308917
```
上面这个大整数有232个十进制位，768个二进制位，768位是目前被破解的最长RSA密钥。当pq的乘积n大到1024位
时，迄今为止还没有人能够利用任何计算工具去完成分解因子的任务。因此，只要密钥长度足够长，用RSA加密的信
息实际上是不能被解破的。  
  
## 8.boost大数库
boost库中有专门进行大数运算的库cpp_int，它的大数类型有很多种  
```
//任意位的大数
typedef number<cpp_int_backend<> >              cpp_int; 
// 固定位的无符号大数，从128到1024位:
typedef number<cpp_int_backend<128, 128, unsigned_magnitude, unchecked, void> >   
uint128_t;
typedef number<cpp_int_backend<256, 256, unsigned_magnitude, unchecked, void> >   
uint256_t;
typedef number<cpp_int_backend<512, 512, unsigned_magnitude, unchecked, void> >   
uint512_t;
typedef number<cpp_int_backend<1024, 1024, unsigned_magnitude, unchecked, void> >
uint1024_t;
// 固定位的有符号大数，从128到1024位:
typedef number<cpp_int_backend<128, 128, signed_magnitude, unchecked, void> >     
int128_t;
typedef number<cpp_int_backend<256, 256, signed_magnitude, unchecked, void> >     
int256_t;
typedef number<cpp_int_backend<512, 512, signed_magnitude, unchecked, void> >     
int512_t;
typedef number<cpp_int_backend<1024, 1024, signed_magnitude, unchecked, void> >   
int1024_t;
```
它的使用方式可普通的内置类型的使用方式完全相同，当然对于大数的初始化，比如普通类型可能无法表示的数字，
可以用字符串进行初始化  
```
#include <boost/multiprecision/cpp_int.hpp>
#include <iostream>
#include <ctime>
using namespace std;
namespace mp = boost::multiprecision;
namespace rp = boost::random;
void test()
{
char* rsa100 =
"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678
9012345678901234567890";
char* rsa50 = "12345678901234567890123456789012345678901234567890";
//用字符串初始化大数
    mp::cpp_int a(rsa100);
mp::cpp_int min(rsa50);
cout << sizeof(a) << endl;
cout << a << endl;
cout << a / 2 << endl;
cout << a / 100 << endl;
```
这就解决了大数求幂的难题，这也就是RSA的所有加密流程。
